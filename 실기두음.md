## 테스트
### whitebox test
원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법  
bc(cld)-test sbcb-coverage  

### 화이트박스 테스트의 종류
* base path(기초 경로)
  * 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법
  * 대표적인 화이트박스 테스트 기법  
* control structure(제어 구조)  
  * condition(조건): 프로그램 모듈 내에 있는 놀지거 조건을 테스트하는 테스트 케이스 설계 기법
  * loop(루프): 프로그램의 반복 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법
  * data flow(데이터 흐름): 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법  
### 화이트박스 테스트의 검증 기준(coverage)
statement(문장)  
branch(분기)  
condition(조건)  
branch/condition(분기/조건)

### blackbox  
ebcec-test  
블랙박스 테스트의 종류
equivalence partitioning(동치 분할 검사)  
boundary value analysis(경계값 분석)  
cause-effect graphing(원인-효과 그래프)  
error guessing(오류 예측)  
comparison(비교)  

## 모듈
결합도-응집도: 결합도는 낮추고 응집도는 올려라
### 결합도
내공외제스자  
내용  
공통  
외부  
제어  
스탬프  
자료(순으로 낮음)  

### 응집도
우논시절통순기
우연적  
논리적  
시간적  
절차적  
통신적(교환적)  
순차적  
기능적  
## 디자인 패턴
생구행->생성구현행위
### 생성
클래스나 객체의 생성과 참조 과정을 정의하는 패턴  
abfps  
abstract factory: 구체적인 클래스에 의존X, 인터페이스를 통해 서로 연관-의존하는 객체들의 그룹으로 생성하여 추상적으로 표현, 연관된 서브 클래스를 묶어 한 번에 교체 가능  
builder: 작은 인스턴스를 조립하여 객체생성, 객체의 생성 과정과 표현 방법을 분리하고 있어, 객체 생성에서도 서로 다른 결과를 만들어낼 수 있음.  
factory method: 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴. 상위 클래스는 인터페이스만 실제 생성은 서브 클래스. 가상 생성자(Virtual construtor)패턴이라고함.  
prototype: 원본 객체를 복제하여 생성 일반적인 방법으로 객체를 생성하고, 비용이 큰 경우 사용  
singleton: 객체 하나를 어디서든 참조 가능, 여러 프로세스가 동시에는 안됨. 1클래스 1인스턴스로 메모리 낭비 최소화  
### 구조
구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴  
abcdfp  
adaptor: 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 없도록 변환해주는 패턴, 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 유용함  
bridge: 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 잇도록 구성한 패턴, 기능과 구현을 2개의 별도 클래스로 구현  
composite: 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴, 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있음.  
decorator: 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴, 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현   
facade: 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴, 서브 클래스들 사이의 통합 인터페이스를 제공하는 래퍼 객체가 필요함.  
flyweight: 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고, 가능한 공유해서 사용함으로써 메모리를 절약하는 패턴, 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있음.  
proxy: 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴, 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용함.
### 행위
구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴.  
cciimmosstv  
chain of responsibility: 요청을 처리할 수 있는 개체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴, 요청을 처리할 수 있는 각 객체들이 고리(chain)로 묶여 있어 요청이 해결될 떄까지 고리를 따라 책임이 넘어감  
command: 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그 남김각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화  
interpreter: 언어에 문법 표현을 정의 SQL이나 통신프로토콜 개발에 사용  
iterator: 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스 사용하도록 하는 패턴내부 표현 방법 노출없이 순차적 접근 가능  
mediator:  수많은 객체들간 복잡한 상호작용(Interface)을 캡슐화 하여 객체로 정의, 객체 사이 의존성 줄여 결합도 감소, 중재자는 객체간 통제와 지시 역할 수행  
memento: 특정 시점에서 객체 내부 상태를 객체화하여 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공, Ctrl+Z 와 같은 기능 개발에 사용  
observer: 한 객체의 상태가 변화하면 객체에 상속되어있는 다른 객체들에게 변화된 상태를 전달, 주로 분산된 시스템간 이벤트를 생성, 발행 하고 이를 수신할 때 사용  
state: 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 객체 상태를 캡슐화 하고 이를 참조하는 방식  
strategy: 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환 가능하게 클라이언트는 독립적으로 원하는 알고리즘 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘 변경 가능  
template method: 상위 클래스에서 골격을 정의, 하위 클래스에서 세부 처리를 구체화 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의  
visitor: 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성 분리된 처리기능은 각 클래스를 방문(Visit)하여 수행

### UI
* 직관성(Intuitiveness): 누구나 쉽게 이해하고, 쉽게 사용할 수 있어야 한다.
* 유효성(Efficiency): 정확하고 완벽하게 사용자의 목표가 달성 될 수 있도록 제작한다.
* 학습성(Learnability): 모두가 쉽게 배우고 사용할 수 있어야 한다.
* 유연성(Flexibility): 사용자의 인터랙션을 최대한 포용하고, 실수를 방지할 수 있도록 제작

### OSI 7계층
물->데->네
전->세->표->응

## TCP/IP
### 프로토콜
프로토콜은 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약  
프로토콜의 기본 요소  
* 구문
* 의미
* 시간
### TCP/IP
### TCP/IP의 구조
### 응용 계층의 주요 프로토콜
## 경로 제어 / 트래픽 제어
### 경로 제어
### 경로 제어 프로토콜
### 트래픽 제어
### 흐름 제어
### 폭주 제어
## 회복 / 병행제어
### 회복
### 병행제어
### 로킹 단위
