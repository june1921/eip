building: 생성과 구현을 분리해서 동일한 생성 절차에서 다양한 객체를 생성  
factory: 상위 클래스는 객체 생성 인터페이스, 하위 클래스는 인스턴스 생성, 상위는 인스턴스를 만드는 방법만, 하위는 데이터 생성과 조작  
prototype: 객체 원형을 제작하고 원형을 수정하는 패턴  
singleton: 전역 객체  
Abstract Factory: 서로 연관되거나 의존적인 객체 조합을 만드는 인터페이스 제공  

bridge: 기능-구현 클래스 연결, 구현에서 추상 계층 분리. (추상, 구현)을 독립적 확장.  
decorator: 기존의 객체에 기능을 추가하는 패턴. 객체간 결합으로 기능을 동적으로 유연하게 확장.  
Facade: 복잡한 시스템에 단순한 인터페이스로 연결.  
flyweight: 다수의 객체에서 공통부분을 뽑아 공유하여 메모리 절약. 여  러 개의 가상 인스턴스를 제공하여 메모리 절감  
proxy: 실제 객체의 대리객체  
composite: 객체를 트리로 재편성, 복합 객체와 단일 객체를 동일 취급.    
adapter: 클래스를 재사용 가능하도록 어댑터 인터페이스, 상속과 위임 두가지 인스턴스 패턴 사용.

mediator: 중재자 객체를 두고 통신을 매개  
interpreter: 여러 구문을 해석하는 클래스를 만드는 패턴  
iterator: 내부구조를 숨기고 객체 내부 원소에 순차적 접근  
observer: 한 객체의 상태가 바뀌면 다른 객체에 연락이 간다. 일대다 상태  
strategy: 알고리즘 군을 하나의 클래스로 만든다.  
memento: 설계 과정에서 객체의 정보를 저장할 필요가 있을 때 사용.  
state: 객체의 상태를 캡슐화하여 클래스화함으로서 코드 수정 최소화가능.  
command: 요청을 객체로 캡슐화하여 실행 취소, 재실행과 같은 조작을 지원하는 디자인 패턴이다.  
template method: 상위 클래스는 바꾸지 않으면서 서브 클래스로 일부 작업 수행  
chain of responsibility: 한 요청을 2개 이상의 객체에서 처리.  
visitor: 처리 기능을 분리하여 별도의 클래스를 만들고 그 클래스의 메서드가 특정 작업 수행.  
