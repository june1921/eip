# 4장 서버 프로그램 구현
## 1. 객체지향 분석 및 설계
### 1. 럼바우(Rumbaugh)의 분석 기법
모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링 하는 기법
* 객체모델링: 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것.
* 동적 모델링: 상태 다이어그램을 이용하여 시간의 흐름에 다른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
* 자료 흐름도를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링.
* 객->동->기
### 객체지향 설계 원칙
SRP, OCP, LSP, ISP, DIP, SOLID 원칙  
* SRP단일 책임 원칙: 객체는 단 하나의 책임만 가져야 한다.
* OCP개방-폐쇄 원칙: 기존의 코드를 변경하지 않고 기능을 추가할 수 있어야 한다.
* LSP리스코프 치환 원칙: 자식 클래스는 부모 클래스 기능 수행가능해야한다.
* ISP인터페이스 분리 원칙: 자신이 사용하지 않는 인터페이스와 의존 관계 X
* DIP의존역전원칙: 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 매정야 한다.
## 2. 모듈
### 1. 결합도(Coupling)
결합도에 따른 품질은 약할수록 좋고 강할수록 나쁘다.  
내용(Content)<공통(Common)<외부(External)<제어(Control)<스탬프(Stamp)<자료(Data)
* 내용: 내부 변수나 기능을 다른 모듈에서 사용
* 공통: 전역변수 참조 및 갱신
* 외부: 외부 포맷, 프로토콜, 인터페이스를 공유
* 제어: 제어 요소를 전달
* 스탬프: 배열, 객체 구조가 전달
* 자료: 파라미터를 통해서만 모듈간의 상호작용이 이뤄질 때
* 내공외제스자
### 2. 응집도(Cohesion)
응집도에 따른 품질은 강할수록 좋고 약할수록 나쁘다.(결합도와 반대)  
우연적(Coincidental)<논리적(Logical)<시간적(Temporal)<절차적(Procedural)<교환(통신)적(Communication)<순차적(Sequential)<기능적(Functional)
* 우연적: 모듈 내부의 구성요소들의 연관이 없는 경우
* 논리적: 유사한 성격을 가지는 처리요소들이 한 모듈에서 처리될 떄
* 시간적: 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우
* 절차적: 구성 요소들이 기능을 순차적으로 수행할 경우
* 교환(통신)적: 동일한 입출력
* 순차적: 출력값이 다른 활동에서 사용될 경우
* 기능적: 모든 기능이 단일한 목적을 위해 수행되는 경우
* 우논시절통순기
### 3. 팬인/팬아웃
* 팬인은 어떤 모듈을 제어하는 모듈의 수이다.
* 팬아웃은 어떤 모듈에 의해 제어되는 모듈의 수를 의미한다.
* 팬인 높을 수록 재사용 잘됨 그러나 단일 장애점 발생할 수 있어 중점적인 관리 및 테스트가 필요하다.
## 단위 모듈
### 단위 모듈
한 가지 동작을 수행하는 기능을 모듈로 구현한 것
### IPC(Inter-Process Communication)
IPC는 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
대표 메소드
* Shared Memory: 메모리 공유하는 다수의 프로세스가 통신
* Socket: 소켓통신
* Semaphore: 공유 자원에 대한 접근 제어를 통해 통신
* Pipes&named Pipes: pipe라고 불리는 fifo 메모리를 공유하여 통신. 한 프로세스가 독점함
### 테스트케이스
구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수하는지를 확인하기 위한 명세서
## 디자인 패턴
생구행->생성구현행위
### 생성
클래스나 객체의 생성과 참조 과정을 정의하는 패턴  
abfps  
abstract factory: 구체적인 클래스에 의존X, 인터페이스를 통해 서로 연관-의존하는 객체들의 그룹으로 생성하여 추상적으로 표현, 연관된 서브 클래스를 묶어 한 번에 교체 가능  
builder: 작은 인스턴스를 조립하여 객체생성, 객체의 생성 과정과 표현 방법을 분리하고 있어, 객체 생성에서도 서로 다른 결과를 만들어낼 수 있음.  
factory method: 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴. 상위 클래스는 인터페이스만 실제 생성은 서브 클래스. 가상 생성자(Virtual construtor)패턴이라고함.  
prototype: 원본 객체를 복제하여 생성 일반적인 방법으로 객체를 생성하고, 비용이 큰 경우 사용  
singleton: 객체 하나를 어디서든 참조 가능, 여러 프로세스가 동시에는 안됨. 1클래스 1인스턴스로 메모리 낭비 최소화  
### 구조
구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴  
abcdfp  
adaptor: 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 없도록 변환해주는 패턴, 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 유용함  
bridge: 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 잇도록 구성한 패턴, 기능과 구현을 2개의 별도 클래스로 구현  
composite: 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴, 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있음.  
decorator: 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴, 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현   
facade: 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴, 서브 클래스들 사이의 통합 인터페이스를 제공하는 래퍼 객체가 필요함.  
flyweight: 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고, 가능한 공유해서 사용함으로써 메모리를 절약하는 패턴, 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있음.  
proxy: 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴, 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용함.
### 행위
구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴.  
cciimmosstv  
chain of responsibility: 요청을 처리할 수 있는 개체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴, 요청을 처리할 수 있는 각 객체들이 고리(chain)로 묶여 있어 요청이 해결될 떄까지 고리를 따라 책임이 넘어감  
command: 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그 남김각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화  
interpreter: 언어에 문법 표현을 정의 SQL이나 통신프로토콜 개발에 사용  
iterator: 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스 사용하도록 하는 패턴내부 표현 방법 노출없이 순차적 접근 가능  
mediator:  수많은 객체들간 복잡한 상호작용(Interface)을 캡슐화 하여 객체로 정의, 객체 사이 의존성 줄여 결합도 감소, 중재자는 객체간 통제와 지시 역할 수행  
memento: 특정 시점에서 객체 내부 상태를 객체화하여 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공, Ctrl+Z 와 같은 기능 개발에 사용  
observer: 한 객체의 상태가 변화하면 객체에 상속되어있는 다른 객체들에게 변화된 상태를 전달, 주로 분산된 시스템간 이벤트를 생성, 발행 하고 이를 수신할 때 사용  
state: 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 객체 상태를 캡슐화 하고 이를 참조하는 방식  
strategy: 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환 가능하게 클라이언트는 독립적으로 원하는 알고리즘 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘 변경 가능  
template method: 상위 클래스에서 골격을 정의, 하위 클래스에서 세부 처리를 구체화 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의  
visitor: 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성 분리된 처리기능은 각 클래스를 방문(Visit)하여 수행
